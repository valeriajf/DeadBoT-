#!/bin/bash

# Script de atualiza√ß√£o autom√°tica do bot
# Autor: Dev Gui
# Vers√£o: 1.0.0
# Compat√≠vel com: VPS, WSL2 e Termux

set -e 

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

detect_environment() {
    if [ -d "/data/data/com.termux" ]; then
        echo "termux"
    elif grep -qi microsoft /proc/version 2>/dev/null; then
        echo "wsl"
    else
        echo "vps"
    fi
}

ENV_TYPE=$(detect_environment)

if [ "$ENV_TYPE" = "termux" ]; then
    TEMP_DIR="$HOME/.cache/takeshi-bot-update"
    mkdir -p "$TEMP_DIR"
else
    TEMP_DIR="/tmp"
fi

print_color() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

print_header() {
    echo
    print_color $CYAN "=================================="
    print_color $CYAN "$1"
    print_color $CYAN "=================================="
    echo
}

ask_yes_no() {
    local question=$1
    while true; do
        read -p "$(echo -e "${YELLOW}${question} (s/n): ${NC}")" yn
        case $yn in
            [SsYy]* ) return 0;;
            [NnNn]* ) return 1;;
            * ) echo "Por favor, responda s (sim) ou n (n√£o).";;
        esac
    done
}

check_dependencies() {
    local missing_deps=()
    
    if ! command -v git &> /dev/null; then
        missing_deps+=("git")
    fi
    
    if ! command -v node &> /dev/null && ! command -v nodejs &> /dev/null; then
        missing_deps+=("nodejs")
    fi
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        print_color $RED "‚ùå Depend√™ncias faltando: ${missing_deps[*]}"
        
        if [ "$ENV_TYPE" = "termux" ]; then
            print_color $YELLOW "üí° Instale com: pkg install ${missing_deps[*]}"
        else
            print_color $YELLOW "üí° Instale as depend√™ncias necess√°rias primeiro."
        fi
        exit 1
    fi
}

check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_color $RED "‚ùå Erro: Este diret√≥rio n√£o √© um reposit√≥rio Git!"
        print_color $YELLOW "üí° Dica: Execute este script na pasta raiz do seu projeto."
        exit 1
    fi
}

check_package_json() {
    if [ ! -f "package.json" ]; then
        print_color $RED "‚ùå Erro: package.json n√£o encontrado!"
        print_color $YELLOW "üí° Dica: Execute este script na pasta raiz do projeto onde est√° o package.json."
        exit 1
    fi
}

get_version() {
    local file=$1
    if [ -f "$file" ]; then
        local node_cmd="node"
        if ! command -v node &> /dev/null && command -v nodejs &> /dev/null; then
            node_cmd="nodejs"
        fi
        
        $node_cmd -pe "JSON.parse(require('fs').readFileSync('$file', 'utf8')).version" 2>/dev/null || echo "n√£o encontrada"
    else
        echo "n√£o encontrada"
    fi
}

check_remote() {
    if ! git remote get-url origin > /dev/null 2>&1; then
        print_color $RED "‚ùå Erro: Remote 'origin' n√£o configurado!"
        print_color $YELLOW "üí° Configure o remote com: git remote add origin <URL_DO_REPOSITORIO>"
        exit 1
    fi
}

create_backup() {
    local backup_dir="backup_$(date +%Y%m%d_%H%M%S)"
    print_color $BLUE "üì¶ Criando backup das altera√ß√µes locais em: $backup_dir"
    
    mkdir -p "$backup_dir"
    
    git status --porcelain | while read status file; do
        if [[ "$status" == " M" ]] || [[ "$status" == "M " ]] || [[ "$status" == "MM" ]]; then
            mkdir -p "$backup_dir/$(dirname "$file")" 2>/dev/null || true
            cp "$file" "$backup_dir/$file" 2>/dev/null || true
            print_color $GREEN "  ‚úÖ Backup criado para: $file"
        fi
    done
    
    echo "backup_dir=$backup_dir" > .update_backup_info
    print_color $GREEN "‚úÖ Backup completo!"
}

show_file_differences() {
    print_color $BLUE "üîç Verificando diferen√ßas entre seu bot e o oficial..."
    
    git fetch origin
    
    local current_branch=$(git branch --show-current)
    local remote_branch="origin/$current_branch"
    
    if ! git show-ref --verify --quiet refs/remotes/$remote_branch; then
        print_color $YELLOW "‚ö†Ô∏è  Branch remota '$remote_branch' n√£o encontrada. Usando origin/main ou origin/master..."
        if git show-ref --verify --quiet refs/remotes/origin/main; then
            remote_branch="origin/main"
        elif git show-ref --verify --quiet refs/remotes/origin/master; then
            remote_branch="origin/master"
        else
            print_color $RED "‚ùå N√£o foi poss√≠vel encontrar uma branch remota v√°lida!"
            exit 1
        fi
    fi
    
    echo "remote_branch=$remote_branch" >> .update_backup_info
    
    local new_files=$(git diff --name-only HEAD..$remote_branch --diff-filter=A)
    if [ ! -z "$new_files" ]; then
        print_color $GREEN "üìÅ Arquivos NOVOS que ser√£o baixados:"
        echo "$new_files" | while read file; do
            print_color $GREEN "  + $file"
        done
        echo
    fi
    
    local deleted_files=$(git diff --name-only HEAD..$remote_branch --diff-filter=D)
    if [ ! -z "$deleted_files" ]; then
        print_color $RED "üóëÔ∏è Arquivos que foram REMOVIDOS no bot oficial:"
        echo "$deleted_files" | while read file; do
            print_color $RED "  - $file"
        done
        echo
        if ask_yes_no "‚ö†Ô∏è  Deseja DELETAR estes arquivos localmente tamb√©m?"; then
            echo "delete_files=yes" >> .update_backup_info
        else
            echo "delete_files=no" >> .update_backup_info
        fi
        echo
    fi
    
    local modified_files=$(git diff --name-only HEAD..$remote_branch --diff-filter=M)
    if [ ! -z "$modified_files" ]; then
        print_color $YELLOW "‚úèÔ∏è Arquivos MODIFICADOS que ser√£o atualizados:"
        echo "$modified_files" | while read file; do
            print_color $YELLOW "  ~ $file"
        done
        echo
    fi
    
    local conflicted_files=""
    if [ ! -z "$modified_files" ]; then
        echo "$modified_files" | while read file; do
            if git diff --quiet HEAD "$file" 2>/dev/null; then
                continue
            else
                echo "$file" >> .potential_conflicts
            fi
        done
        
        if [ -f .potential_conflicts ]; then
            conflicted_files=$(cat .potential_conflicts)
            rm .potential_conflicts
        fi
    fi
    
    if [ ! -z "$conflicted_files" ]; then
        print_color $PURPLE "‚ö†Ô∏è  ATEN√á√ÉO: Os seguintes arquivos foram modificados TANTO localmente QUANTO remotamente:"
        echo "$conflicted_files" | while read file; do
            print_color $PURPLE "  ‚ö†Ô∏è  $file"
        done
        print_color $YELLOW "üîß Ser√° usado o merge strategy para tentar mesclar automaticamente."
        echo
    fi
}

apply_updates() {
    source .update_backup_info
    
    print_color $BLUE "üîÑ Aplicando atualiza√ß√µes..."
    
    git config pull.rebase false 2>/dev/null || true
    
    local merge_strategy="ort"
    if ! git merge -s ort --help &> /dev/null; then
        merge_strategy="recursive"
        print_color $YELLOW "‚ÑπÔ∏è  Usando estrat√©gia 'recursive' (vers√£o antiga do Git)"
    fi
    
    print_color $YELLOW "üîß Usando estrat√©gia de merge '$merge_strategy' para mesclar altera√ß√µes..."
    
    if git merge -X $merge_strategy $remote_branch --no-commit --no-ff 2>/dev/null; then
        print_color $GREEN "‚úÖ Merge autom√°tico realizado com sucesso!"
        
        if [[ "${delete_files:-no}" == "yes" ]]; then
            git diff --name-only HEAD..$remote_branch --diff-filter=D | while read file; do
                if [ -f "$file" ]; then
                    rm "$file"
                    git add "$file"
                    print_color $GREEN "  üóëÔ∏è Arquivo deletado: $file"
                fi
            done
        fi
        
        git commit -m "ü§ñ Atualiza√ß√£o autom√°tica via script update.sh" 2>/dev/null || {
            print_color $YELLOW "‚ÑπÔ∏è Nenhuma altera√ß√£o para commit (j√° estava atualizado)"
        }
        
    else
        print_color $RED "‚ùå N√£o foi poss√≠vel fazer merge autom√°tico!"
        
        git merge --abort 2>/dev/null || true
        
        print_color $YELLOW "üîç Verificando arquivos com conflito..."
        
        local conflicted=$(git diff --name-only HEAD $remote_branch)
        
        print_color $RED "‚ö†Ô∏è  Os seguintes arquivos t√™m conflitos que precisam ser resolvidos manualmente:"
        echo "$conflicted" | while read file; do
            print_color $RED "  ‚ö†Ô∏è  $file"
        done
        
        echo
        print_color $YELLOW "üí° O que fazer agora:"
        print_color $YELLOW "  1. Aceitar TODAS as altera√ß√µes do reposit√≥rio oficial (sobrescrever local)"
        print_color $YELLOW "  2. Manter TODAS as altera√ß√µes locais (ignorar reposit√≥rio oficial)" 
        print_color $YELLOW "  3. Resolver conflitos manualmente depois"
        echo
        
        echo "Escolha uma op√ß√£o:"
        echo "1) Aceitar tudo do bot oficial (CUIDADO: vai sobrescrever suas altera√ß√µes!)"
        echo "2) Manter tudo local (n√£o vai atualizar)"
        echo "3) Cancelar e resolver manualmente"
        
        read -p "Op√ß√£o (1-3): " choice
        
        case $choice in
            1)
                print_color $YELLOW "‚ö†Ô∏è  ATEN√á√ÉO: Suas altera√ß√µes locais ser√£o PERDIDAS!"
                if ask_yes_no "Tem CERTEZA que quer continuar?"; then
                    git reset --hard $remote_branch
                    print_color $GREEN "‚úÖ Reposit√≥rio atualizado com vers√£o remota!"
                else
                    print_color $BLUE "‚ÑπÔ∏è Opera√ß√£o cancelada."
                    return 1
                fi
                ;;
            2)
                print_color $BLUE "‚ÑπÔ∏è Mantendo altera√ß√µes locais. Reposit√≥rio n√£o foi atualizado."
                return 1
                ;;
            3)
                print_color $BLUE "‚ÑπÔ∏è Opera√ß√£o cancelada. Resolva os conflitos manualmente."
                print_color $YELLOW "üí° Use: git merge $remote_branch"
                return 1
                ;;
            *)
                print_color $RED "‚ùå Op√ß√£o inv√°lida!"
                return 1
                ;;
        esac
    fi
}

cleanup() {
    rm -f .update_backup_info .potential_conflicts
}

main() {
    print_header "ü§ñ SCRIPT DE ATUALIZA√á√ÉO TAKESHI BOT"
    
    case $ENV_TYPE in
        termux)
            print_color $CYAN "üì± Ambiente: Termux (Android)"
            ;;
        wsl)
            print_color $CYAN "üêß Ambiente: WSL2 (Windows Subsystem for Linux)"
            ;;
        vps)
            print_color $CYAN "üñ•Ô∏è  Ambiente: VPS/Linux"
            ;;
    esac
    echo
    
    print_color $BLUE "üîç Verificando depend√™ncias..."
    check_dependencies
    
    print_color $BLUE "üîç Verificando ambiente..."
    check_git_repo
    check_package_json
    check_remote
    
    print_color $CYAN "üìä INFORMA√á√ïES DE VERS√ÉO:"
    local local_version=$(get_version "package.json")
    
    git fetch origin 2>/dev/null || {
        print_color $RED "‚ùå Erro ao conectar com o reposit√≥rio oficial!"
        print_color $YELLOW "üí° Verifique sua conex√£o de internet e as permiss√µes do reposit√≥rio."
        exit 1
    }
    
    local current_branch=$(git branch --show-current)
    local remote_branch="origin/$current_branch"
    
    if ! git show-ref --verify --quiet refs/remotes/$remote_branch; then
        if git show-ref --verify --quiet refs/remotes/origin/main; then
            remote_branch="origin/main"
        elif git show-ref --verify --quiet refs/remotes/origin/master; then
            remote_branch="origin/master"
        fi
    fi
    
    local remote_version="n√£o encontrada"
    local remote_package="$TEMP_DIR/remote_package_$$.json"
    if git show $remote_branch:package.json > "$remote_package" 2>/dev/null; then
        remote_version=$(get_version "$remote_package")
        rm -f "$remote_package"
    fi
    
    print_color $([ "$local_version" = "$remote_version" ] && echo $GREEN || echo $RED) "  üì¶ Sua vers√£o:     $local_version"
    print_color $GREEN "  üåê Vers√£o oficial: $remote_version"
    echo
    
    if ! git diff-index --quiet HEAD --; then
        print_color $YELLOW "‚ö†Ô∏è   Voc√™ tem altera√ß√µes locais n√£o salvas!"
        if ask_yes_no "Deseja criar um backup das suas altera√ß√µes antes de continuar?"; then
            create_backup
        fi
        echo
    fi
    
    if git diff --quiet HEAD $remote_branch 2>/dev/null; then
        print_color $GREEN "‚úÖ Seu bot j√° est√° ATUALIZADO!"
        print_color $BLUE "‚ÑπÔ∏è  N√£o h√° nada para baixar."
        cleanup
        exit 0
    fi
    
    show_file_differences
    
    if ask_yes_no "üöÄ Deseja APLICAR todas essas atualiza√ß√µes?"; then
        apply_updates
        
        if [ $? -eq 0 ]; then
            print_color $GREEN "‚úÖ ATUALIZA√á√ÉO CONCLU√çDA COM SUCESSO!"
            
            local new_version=$(get_version "package.json")
            if [ "$new_version" != "$local_version" ]; then
                print_color $CYAN "üéâ Vers√£o atualizada: $local_version ‚Üí $new_version"
            fi
            
            print_color $YELLOW "üí° PR√ìXIMOS PASSOS:"
            print_color $YELLOW "  1. Verifique se tudo est√° funcionando corretamente"
            if [ "$ENV_TYPE" = "termux" ]; then
                print_color $YELLOW "  2. Execute 'npm install' se houver novas depend√™ncias"
            else
                print_color $YELLOW "  2. Execute 'npm install' se houver novas depend√™ncias"
            fi
            print_color $YELLOW "  3. Reinicie o bot se necess√°rio"
            
            if [ -f .update_backup_info ]; then
                source .update_backup_info
                if [ ! -z "${backup_dir:-}" ] && [ -d "$backup_dir" ]; then
                    print_color $BLUE "üì¶ Backup das suas altera√ß√µes salvo em: $backup_dir"
                fi
            fi
        else
            print_color $RED "‚ùå Atualiza√ß√£o n√£o foi completada."
            print_color $YELLOW "üí° Verifique os erros acima e tente novamente."
        fi
    else
        print_color $BLUE "‚ÑπÔ∏è  Atualiza√ß√£o cancelada pelo usu√°rio."
    fi
    
    cleanup
    print_color $CYAN "üèÅ Script finalizado!"
}

trap cleanup EXIT INT TERM

main "$@"