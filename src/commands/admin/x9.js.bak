const fs = require('fs');
const path = require('path');

// Caminhos dos arquivos
const LOGS_FILE = path.join(__dirname, '../../database/x9_logs.json');
const CONFIG_FILE = path.join(__dirname, '../../database/x9_config.json');

// Inicializar arquivos se nÃ£o existirem
const initFiles = () => {
  // Arquivo de logs
  if (!fs.existsSync(LOGS_FILE)) {
    fs.writeFileSync(LOGS_FILE, JSON.stringify([], null, 2));
  }
  
  // Arquivo de configuraÃ§Ã£o (grupos com x9 ativado)
  if (!fs.existsSync(CONFIG_FILE)) {
    fs.writeFileSync(CONFIG_FILE, JSON.stringify({}, null, 2));
  }
};

// Carregar logs
const loadLogs = () => {
  try {
    const data = fs.readFileSync(LOGS_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return [];
  }
};

// Salvar logs
const saveLogs = (logs) => {
  fs.writeFileSync(LOGS_FILE, JSON.stringify(logs, null, 2));
};

// Carregar configuraÃ§Ã£o
const loadConfig = () => {
  try {
    const data = fs.readFileSync(CONFIG_FILE, 'utf8');
    return JSON.parse(data);
  } catch (error) {
    return {};
  }
};

// Salvar configuraÃ§Ã£o
const saveConfig = (config) => {
  fs.writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2));
};

// Verificar se x9 estÃ¡ ativo no grupo
const isX9Active = (groupId) => {
  const config = loadConfig();
  return config[groupId] === true;
};

// Ativar/desativar x9 em um grupo
const toggleX9 = (groupId, active) => {
  const config = loadConfig();
  config[groupId] = active;
  saveConfig(config);
};

// Adicionar um novo log
const addLog = (action, adminId, adminName, groupId, groupName, target = null, details = '') => {
  const logs = loadLogs();
  const newLog = {
    id: logs.length + 1,
    timestamp: new Date().toISOString(),
    date: new Date().toLocaleString('pt-BR'),
    action: action,
    admin: {
      id: adminId,
      name: adminName
    },
    group: {
      id: groupId,
      name: groupName
    },
    target: target,
    details: details
  };
  
  logs.push(newLog);
  
  // Manter apenas os Ãºltimos 500 logs
  if (logs.length > 500) {
    logs.shift();
  }
  
  saveLogs(logs);
  return newLog;
};

// Formatar logs para exibiÃ§Ã£o
const formatLogs = (logs, limit = 10) => {
  if (logs.length === 0) {
    return 'ğŸ“‹ *Nenhuma aÃ§Ã£o registrada ainda*';
  }
  
  const recentLogs = logs.slice(-limit).reverse();
  let message = `ğŸ•µï¸ *RELATÃ“RIO X9 - AÃ‡Ã•ES DOS ADMINS* ğŸ•µï¸\n\n`;
  message += `ğŸ“Š Total de aÃ§Ãµes: ${logs.length}\n`;
  message += `ğŸ“… Ãšltimas ${Math.min(limit, logs.length)} aÃ§Ãµes:\n\n`;
  
  recentLogs.forEach((log) => {
    message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
    message += `ğŸ”¢ *#${log.id}* | ${log.date}\n`;
    message += `ğŸ‘¤ *Admin:* ${log.admin.name}\n`;
    message += `ğŸ“± *Grupo:* ${log.group.name}\n`;
    message += `âš¡ *AÃ§Ã£o:* ${log.action}\n`;
    if (log.target) {
      message += `ğŸ¯ *Alvo:* ${log.target}\n`;
    }
    if (log.details) {
      message += `ğŸ“ *Detalhes:* ${log.details}\n`;
    }
    message += `\n`;
  });
  
  return message;
};

// Filtrar logs por admin
const filterLogsByAdmin = (logs, adminId) => {
  return logs.filter(log => log.admin.id === adminId);
};

// Filtrar logs por grupo
const filterLogsByGroup = (logs, groupId) => {
  return logs.filter(log => log.group.id === groupId);
};

// Filtrar logs por tipo de aÃ§Ã£o
const filterLogsByAction = (logs, action) => {
  return logs.filter(log => log.action.toLowerCase().includes(action.toLowerCase()));
};

module.exports = {
  name: "x9",
  description: "ğŸ•µï¸ Ativa/desativa monitoramento de admins",
  commands: ["x9"],
  usage: `#x9 1 - Ativar monitoramento
#x9 0 - Desativar monitoramento
#x9 status - Ver se estÃ¡ ativo`,
  handle: async ({ socket, remoteJid, args, isGroup, isGroupAdmin, isOwner, userJid, webMessage }) => {
    
    // Inicializar arquivos
    initFiles();
    
    // Verificar se Ã© grupo
    if (!isGroup) {
      return await socket.sendMessage(remoteJid, { text: "âŒ Este comando sÃ³ funciona em grupos!" });
    }
    
    // Se nÃ£o tiver argumentos, mostrar status
    if (args.length === 0) {
      const isActive = isX9Active(remoteJid);
      const statusMsg = isActive 
        ? "âœ… *X9 ATIVO* ğŸ•µï¸\n\nO monitoramento estÃ¡ em funcionamento!"
        : "âš ï¸ *X9 INATIVO*\n\nUse `#x9 1` para ativar o monitoramento.";
      return await socket.sendMessage(remoteJid, { text: statusMsg });
    }
    
    const subCommand = args[0].toLowerCase();
    
    // Ativar/Desativar X9 (apenas admins)
    if (subCommand === '1' || subCommand === '0') {
      // Verificar se Ã© admin do grupo (verificaÃ§Ã£o mais robusta)
      let isAdmin = isGroupAdmin || isOwner;
      
      // Se a verificaÃ§Ã£o padrÃ£o falhar, verificar manualmente
      if (!isAdmin && isGroup) {
        try {
          const groupMetadata = await socket.groupMetadata(remoteJid);
          const participant = groupMetadata.participants.find(p => p.id === userJid);
          isAdmin = participant && (participant.admin === 'admin' || participant.admin === 'superadmin');
        } catch (error) {
          console.error('Erro ao verificar admin:', error);
        }
      }
      
      if (!isAdmin) {
        return await socket.sendMessage(remoteJid, { text: "âŒ Apenas admins podem ativar/desativar o X9!" });
      }
      
      const activate = subCommand === '1';
      toggleX9(remoteJid, activate);
      
      if (activate) {
        // Adicionar reaÃ§Ã£o de sucesso
        try {
          if (webMessage && webMessage.key) {
            await socket.sendMessage(remoteJid, {
              react: { text: "ğŸ•µï¸", key: webMessage.key }
            });
          }
        } catch (e) {}
        
        return await socket.sendMessage(remoteJid, { text: "âœ… *X9 ATIVADO!* ğŸ•µï¸\n\nTodas as aÃ§Ãµes dos admins serÃ£o monitoradas a partir de agora." });
      } else {
        // Adicionar reaÃ§Ã£o de desativado
        try {
          if (webMessage && webMessage.key) {
            await socket.sendMessage(remoteJid, {
              react: { text: "âš ï¸", key: webMessage.key }
            });
          }
        } catch (e) {}
        
        return await socket.sendMessage(remoteJid, { text: "âš ï¸ *X9 DESATIVADO!*\n\nO monitoramento foi desativado. Use `#x9 1` para reativar." });
      }
    }
    
    // Status
    if (subCommand === 'status') {
      const isActive = isX9Active(remoteJid);
      const statusMsg = isActive 
        ? "âœ… *X9 ATIVO* ğŸ•µï¸\n\nO monitoramento estÃ¡ em funcionamento!"
        : "âš ï¸ *X9 INATIVO*\n\nUse `#x9 1` para ativar o monitoramento.";
      return await socket.sendMessage(remoteJid, { text: statusMsg });
    }
    
    // Ajuda
    if (subCommand === 'ajuda' || subCommand === 'help') {
      const helpText = `
ğŸ•µï¸ *COMANDO X9 - AJUDA* ğŸ•µï¸

*Comandos disponÃ­veis (apenas admins):*
â€¢ *#x9 1* - Ativar monitoramento
â€¢ *#x9 0* - Desativar monitoramento
â€¢ *#x9 status* - Ver se estÃ¡ ativo
â€¢ *#x9 ajuda* - Exibir esta ajuda

*AÃ§Ãµes monitoradas:*
âœ“ Adicionar membros
âœ“ Remover membros
âœ“ Promover a admin
âœ“ Rebaixar admin
âœ“ Alterar nome do grupo
âœ“ Alterar descriÃ§Ã£o
âœ“ Alterar foto do grupo
âœ“ Alterar configuraÃ§Ãµes

_Use #x9 1 para ativar!_ ğŸ•µï¸`;
      return await socket.sendMessage(remoteJid, { text: helpText });
    }
    
    // Comando invÃ¡lido
    return await socket.sendMessage(remoteJid, { text: "âŒ Comando invÃ¡lido! Use *#x9 ajuda* para ver os comandos disponÃ­veis." });
  }
};

// Exportar funÃ§Ãµes auxiliares para uso no middleware
module.exports.addLog = addLog;
module.exports.isX9Active = isX9Active;
module.exports.initFiles = initFiles;
