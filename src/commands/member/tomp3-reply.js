/**
 * Converte v√≠deos para √°udio MP3
 * Vers√£o espec√≠fica para MARCAR v√≠deos
 *
 * @author Adaptado para DeadBoT
 */

const { PREFIX, TEMP_DIR } = require(`${BASE_DIR}/config`);
const { exec } = require("child_process");
const fs = require("fs");
const path = require("path");
const { InvalidParameterError, WarningError } = require(`${BASE_DIR}/errors`);
const { getRandomNumber } = require(`${BASE_DIR}/utils`);
const { downloadContentFromMessage } = require("baileys");

module.exports = {
  name: "tomp3-reply",
  description: "Converte v√≠deos marcados para √°udio MP3!",
  commands: ["tomp3-reply", "tomp3r", "video2mp3-reply"],
  usage: `${PREFIX}tomp3-reply (marque um v√≠deo)`,
  
  /**
   * @param {CommandHandleProps} props
   * @returns {Promise<void>}
   */
  handle: async ({
    isReply,
    webMessage,
    sendWaitReact,
    sendSuccessReact,
    sendErrorReply,
    sendSuccessReply,
    sendAudioFromFile,
  }) => {
    try {
      if (!isReply) {
        throw new InvalidParameterError(
          "‚ùå Voc√™ precisa marcar um v√≠deo para usar este comando!\n\n" +
          `*Como usar:*\n` +
          `1Ô∏è‚É£ Marque/responda uma mensagem de v√≠deo\n` +
          `2Ô∏è‚É£ Digite: ${PREFIX}tomp3-reply\n\n` +
          `üí° *Dica:* Para enviar v√≠deo com legenda, use ${PREFIX}tomp3`
        );
      }

      await sendWaitReact();
      await sendSuccessReply("üéµ Convertendo v√≠deo marcado para √°udio MP3...");

      const inputPath = await downloadQuotedVideo(webMessage);

      if (!inputPath || !fs.existsSync(inputPath)) {
        throw new WarningError("‚ùå N√£o foi poss√≠vel baixar o v√≠deo marcado. Tente novamente.");
      }

      const videoStats = fs.statSync(inputPath);
      const videoSizeMB = (videoStats.size / 1024 / 1024).toFixed(2);

      const outputPath = path.resolve(
        TEMP_DIR,
        `audio_${getRandomNumber(10_000, 99_999)}.mp3`
      );

      await convertVideoToMp3(inputPath, outputPath);

      if (!fs.existsSync(outputPath)) {
        throw new WarningError("‚ùå Falha na convers√£o do √°udio.");
      }

      const audioStats = fs.statSync(outputPath);
      const audioSizeMB = (audioStats.size / 1024 / 1024).toFixed(2);

      await sendSuccessReact();
      await sendAudioFromFile(outputPath);

      await sendSuccessReply(
        `‚úÖ *√Åudio extra√≠do com sucesso!*\n\n` +
        `üìä *Tamanho:* ${audioSizeMB} MB\n` +
        `üéµ *Formato:* MP3 192kbps\n` +
        `üíö *by DeadBoT*`
      );

      cleanupFile(inputPath);
      cleanupFile(outputPath);

    } catch (error) {
      if (error instanceof InvalidParameterError || error instanceof WarningError) {
        throw error;
      }
      
      await sendErrorReply(
        `‚ùå Erro ao converter o v√≠deo: ${error.message}\n\n` +
        `üí° Verifique se o FFmpeg est√° instalado no servidor.`
      );
    }
  },
};

/**
 * Baixa v√≠deo da mensagem marcada (reply)
 * Busca em m√∫ltiplos lugares na estrutura da mensagem
 * @param {Object} webMessage - Mensagem do WhatsApp
 * @returns {Promise<string>} Caminho do arquivo baixado
 */
async function downloadQuotedVideo(webMessage) {
  let videoMessage = null;

  // Busca 1: contextInfo.quotedMessage.videoMessage (padr√£o)
  if (webMessage?.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage) {
    videoMessage = webMessage.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage;
  }
  
  // Busca 2: contextInfo.quotedMessage.viewOnceMessage.message.videoMessage
  else if (webMessage?.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessage?.message?.videoMessage) {
    videoMessage = webMessage.message.extendedTextMessage.contextInfo.quotedMessage.viewOnceMessage.message.videoMessage;
  }
  
  // Busca 3: contextInfo.quotedMessage.viewOnceMessageV2.message.videoMessage
  else if (webMessage?.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2?.message?.videoMessage) {
    videoMessage = webMessage.message.extendedTextMessage.contextInfo.quotedMessage.viewOnceMessageV2.message.videoMessage;
  }
  
  // Busca 4: Busca recursiva em toda a estrutura (√∫ltimo recurso)
  else {
    videoMessage = findVideoMessageRecursive(webMessage);
  }

  if (!videoMessage) {
    throw new WarningError(
      "‚ùå V√≠deo marcado n√£o encontrado!\n\n" +
      `üí° *Certifique-se de:*\n` +
      `‚Ä¢ Marcar/responder uma mensagem que cont√©m v√≠deo\n` +
      `‚Ä¢ O v√≠deo n√£o seja muito antigo\n` +
      `‚Ä¢ O v√≠deo ainda esteja dispon√≠vel no servidor`
    );
  }

  const stream = await downloadContentFromMessage(videoMessage, "video");

  let buffer = Buffer.from([]);
  for await (const chunk of stream) {
    buffer = Buffer.concat([buffer, chunk]);
  }

  if (buffer.length === 0) {
    throw new Error("Buffer de v√≠deo vazio");
  }

  const filePath = path.resolve(
    TEMP_DIR,
    `video_quoted_${getRandomNumber(10_000, 99_999)}.mp4`
  );

  fs.writeFileSync(filePath, buffer);
  
  return filePath;
}

/**
 * Busca videoMessage recursivamente em toda a estrutura da mensagem
 * @param {Object} obj - Objeto para buscar
 * @param {number} maxDepth - Profundidade m√°xima
 * @param {number} currentDepth - Profundidade atual
 * @returns {Object|null} videoMessage se encontrado
 */
function findVideoMessageRecursive(obj, maxDepth = 6, currentDepth = 0) {
  if (!obj || typeof obj !== 'object' || currentDepth > maxDepth) {
    return null;
  }
  
  // Se o objeto atual tem as propriedades de um videoMessage, retorna
  if (obj.url && obj.mimetype && obj.fileSha256 && obj.mediaKey) {
    return obj;
  }
  
  // Busca recursivamente em todos os valores do objeto
  for (const [key, value] of Object.entries(obj)) {
    if (value && typeof value === 'object') {
      // Prioriza buscar em keys que contenham 'video'
      if (key.toLowerCase().includes('video')) {
        const result = findVideoMessageRecursive(value, maxDepth, currentDepth + 1);
        if (result) return result;
      }
    }
  }
  
  // Segunda passagem: busca em todas as outras keys
  for (const value of Object.values(obj)) {
    if (value && typeof value === 'object') {
      const result = findVideoMessageRecursive(value, maxDepth, currentDepth + 1);
      if (result) return result;
    }
  }
  
  return null;
}

/**
 * Converte v√≠deo para MP3 usando FFmpeg
 * @param {string} inputPath - Caminho do v√≠deo de entrada
 * @param {string} outputPath - Caminho do √°udio de sa√≠da
 * @returns {Promise<void>}
 */
function convertVideoToMp3(inputPath, outputPath) {
  return new Promise((resolve, reject) => {
    const ffmpegCommand = `ffmpeg -i "${inputPath}" -vn -acodec libmp3lame -ab 192k -ar 44100 -y "${outputPath}"`;

    exec(ffmpegCommand, { timeout: 60000 }, (error, stdout, stderr) => {
      if (error) {
        return reject(new Error("Falha ao converter o v√≠deo. Verifique se o FFmpeg est√° instalado."));
      }

      resolve();
    });
  });
}

/**
 * Remove arquivo de forma segura
 * @param {string} filePath - Caminho do arquivo
 */
function cleanupFile(filePath) {
  try {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  } catch (error) {
    console.error(`Erro ao remover arquivo:`, error.message);
  }
}